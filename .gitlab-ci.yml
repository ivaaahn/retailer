workflow:
  rules:
    - if: $CI_COMMIT_BRANCH != "main" && $CI_PIPELINE_SOURCE != "merge_request_event"
      when: never
    - when: always

variables:
  PY_VERSION: "3.10"
  POETRY_VERSION: "1.2.2"
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}/main
  PIP_CACHE_KEY: "pip-cache"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"


image: python:${PY_VERSION}

stages:
  - lint
  - unit_tests
  - build
  - integration_tests

linters:
  stage: lint
  variables:
    VENV_CACHE_KEY: "$CI_JOB_STAGE-$CI_COMMIT_REF_SLUG"
  tags:
    - local
    - docker
  cache:
    - key: ${PIP_CACHE_KEY}
      paths:
        - ${PIP_CACHE_DIR}
    - key: ${VENV_CACHE_KEY}
      paths:
        - .venv
  before_script:
    - pip install poetry==${POETRY_VERSION}
    - poetry config virtualenvs.in-project true
    - poetry install --only linters
  script:
    - poetry run black --check --diff .
    - poetry run isort --check --diff .


unit_tests:
  stage: unit_tests
  tags:
    - local
    - docker
  cache:
    - key: ${PIP_CACHE_KEY}
      paths:
        - ${PIP_CACHE_DIR}
      policy: pull
    - key:
        files:
          - poetry.lock
      paths:
        - .venv
  before_script:
    - pip install poetry==${POETRY_VERSION}
    - poetry config virtualenvs.in-project true
    - poetry install --without linters --without dev
  script:
    - poetry run pytest -vv --color=yes --junitxml="pytest-junit.xml" ./retailer/tests/app/unit
  artifacts:
    when: always
    reports:
      junit: pytest-junit.xml

build_image:
  stage: build
  tags:
    - local
    - shell
  before_script:
    - export APP_VERSION=$(grep -E -o "(version = \")(.*)\"" pyproject.toml | cut -d\" -f2)
    - echo "APP_VERSION=${APP_VERSION}" >> pipeline.env
  script:
    - docker build -f deploy/test/Dockerfile -t ${IMAGE_NAME}:${APP_VERSION} .
  artifacts:
    reports:
      dotenv:
        - pipeline.env

push_image:
  stage: build
  tags:
    - local
    - shell
  needs:
    - build_image
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
  script:
    - docker push ${IMAGE_NAME}:${APP_VERSION}

integration_tests:
  stage: integration_tests
  tags:
    - local
    - docker
  variables:
    POSTGRES_DB: test
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    RABBITMQ_DEFAULT_USER: user
    RABBITMQ_DEFAULT_PASS: user
    CONFIG_PATH: etc/.env.tests_ci

  cache:
    - key: ${PIP_CACHE_KEY}
      paths:
        - ${PIP_CACHE_DIR}
      policy: pull
    - key:
        files:
          - poetry.lock
      paths:
        - .venv

  services:
    - name: postgres:alpine
      alias: pg
    - name: redis:alpine
      alias: redis
    - name: rabbitmq:3-alpine
      alias: rabbit

  before_script:
    - pip install poetry==${POETRY_VERSION}
    - poetry config virtualenvs.in-project true
    - poetry install --without linters --without dev
    - cd retailer
    - poetry run alembic upgrade head
  script:
    - poetry run pytest -vv --color=yes --junitxml="pytest-junit.xml" ./tests/app/integration
  artifacts:
    when: always
    reports:
      junit: ./retailer/pytest-junit.xml


