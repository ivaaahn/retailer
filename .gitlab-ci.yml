workflow:
  rules:
    - if: $CI_COMMIT_BRANCH != "main" && $CI_PIPELINE_SOURCE != "merge_request_event"
      when: never
    - when: always

variables:
  PY_VERSION: "3.10"
  POETRY_VERSION: "1.2.2"
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}/main
  IMAGE_TAG: "1.0"
#  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"


image: python:${PY_VERSION}

stages:
  - lint
  - test
  - build

#cache:
#  key:
#    files:
#      - poetry.lock
#      - .gitlab-ci.yml
#    prefix: ${CI_JOB_NAME}
#  paths:
#    - .venv
#    - .cache/pip

linters:
  when: manual
  stage: lint
  tags:
    - local
    - docker
  before_script:
    - pip install poetry==${POETRY_VERSION}
    - poetry config virtualenvs.in-project true
    - poetry install --only linters
  script:
    - poetry run black --check --diff .
    - poetry run isort --check --diff .

unit_tests:
  when: manual
  stage: test
  tags:
    - local
    - docker
  before_script:
    - pip install poetry==${POETRY_VERSION}
    - poetry config virtualenvs.in-project true
    - poetry install --without linters --without dev
  script:
    - poetry run pytest -vv --color=yes --junitxml="pytest-junit.xml"
  artifacts:
    when: always
    reports:
      junit: pytest-junit.xml

build_image:
  tags:
    - local
    - shell
  stage: build
  script:
    - docker build -f deploy/test/Dockerfile -t ${IMAGE_NAME}:${IMAGE_TAG} .

push_image:
  tags:
    - local
    - shell
  stage: build
  needs:
    - build_image
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
  script:
    - docker push ${IMAGE_NAME}:${IMAGE_TAG}


